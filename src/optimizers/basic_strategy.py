import os
import numpy as np
import math
import pandas as pd
import pickle

from pathlib import *
from datetime import datetime
from simulator.grid.cases.one_consumer import build_grid
from util.util import *
from util.util import save_to_pickle


class Simulator(object):
    """Model of the Simulator"""

    def __init__(
        self,
        heat_demand,
        time_interval,
        pipe_len,
        pipe_diameter,
        historical_t_supply,
        historical_t_return,
        max_flow_speed,
        min_flow_speed,
        max_supply_temp,
        min_supply_temp,
        min_return_temp,
        control_with_temp,
    ):
        self.grid = build_grid(
            heat_demand / MW_W,
            pipe_len,
            pipe_diameter,
            historical_t_supply,
            historical_t_return,
            max_flow_speed,
            min_flow_speed,
            max_supply_temp,
            min_supply_temp,
            min_return_temp,
            control_with_temp,
        )
        self.grid.clear()
        self.heat_demand = heat_demand
        self.time_interval = time_interval

    def reset(self, heat_demand, initial_pipe_states):
        self.grid.reset(
            demands=[heat_demand],
            pipe_states=initial_pipe_states,
        )

    def get_Q(
        self,
        temp_sup,
    ):
        condition_flags = []
        for t in range(TIME_HORIZON):
            ret = self.grid.solve_one_step(temp=[temp_sup[t]])
            condition_flags.append(ret[-1])
            if t == self.time_interval - 1:
                plug_states = self.grid.get_pipe_states()

        assert not np.any(condition_flags), "might need higher temperature"

        for producer in self.grid.producers:
            mass_flow = producer.mass_flow[0]
            ret_temp = producer.temp[1]

        return mass_flow * (temp_sup - ret_temp) * producer.heat_capacity, plug_states


class BasicStrategy:
    """
    Calculation of costs generated by basic strategy.
    """

    def __init__(
        self,
        constant_temp,
        pipe_len,
        pipe_diameter,
        time_interval,
        max_flow_speed,
        min_flow_speed,
        max_mass_flow,
        min_mass_flow,
        max_supply_temp,
        min_supply_temp,
        min_return_temp,
        historical_t_supply,
        historical_t_return,
    ):
        self.data_p = Path(__file__).parents[2] / "data"
        self.store_p = (
            Path(__file__).parents[2] / "results/upper_bound_basic_strategy_trial"
        )
        self.now = datetime.now().strftime("%Y_%m_%d_%H_%M_%S")
        self.constant_temp = constant_temp
        self.pipe_len = pipe_len
        self.pipe_diameter = pipe_diameter
        self.time_interval = time_interval
        self.max_flow_speed = max_flow_speed
        self.min_flow_speed = min_flow_speed
        self.max_mass_flow = max_mass_flow
        self.min_mass_flow = min_mass_flow
        self.max_supply_temp = max_supply_temp
        self.min_supply_temp = min_supply_temp
        self.min_return_temp = min_return_temp
        self.historical_t_supply = historical_t_supply
        self.historical_t_return = historical_t_return
        self.CHP_KEY_PTS = np.array(
            [
                [10, 5],
                [0, 10],
                [0, 50],
                [70, 35],
            ]
        )
        self.CHP_KEY_PTS *= MW_W
        self.Q_MAX = max(EXTREME_POINTS)[0] * MW_W
        self.heat_demand = np.array(pd.read_csv(self.data_p / "heat_demand_test.csv"))
        self.electricity_price = np.array(
            pd.read_csv(self.data_p / "day_ahead_electricity_price_test.csv")
        )
        self.number_of_episodes = len(self.heat_demand)
        self.sim = Simulator(
            heat_demand=self.heat_demand[0],
            time_interval=time_interval,
            pipe_len=pipe_len,
            pipe_diameter=pipe_diameter,
            historical_t_supply=historical_t_supply,
            historical_t_return=historical_t_return,
            max_flow_speed=max_flow_speed,
            min_flow_speed=min_flow_speed,
            max_supply_temp=max_supply_temp,
            min_supply_temp=min_supply_temp,
            min_return_temp=min_return_temp,
            control_with_temp=True,
        )

    def optimize(self, heat_demand, electricity_price, plug_states=None):
        temp = np.ones(TIME_HORIZON) * self.constant_temp
        electricity_prod_switch = np.zeros(TIME_HORIZON, dtype=bool)
        electricity_prod_switch[electricity_price > a[1]] = 1
        self.sim.reset(heat_demand * MW_W, plug_states)
        Q, plug_states = self.sim.get_Q(temp)
        [[x1, y1], [x2, y2]] = self.CHP_KEY_PTS[2:]
        Q_bound = np.copy(Q)
        Q_bound[Q_bound > self.Q_MAX] = self.Q_MAX
        electricity_prod = y2 / x2 * Q_bound
        electricity_prod[Q_bound < self.CHP_KEY_PTS[0, 0]] = self.CHP_KEY_PTS[1, 1]
        electricity_prod[electricity_prod_switch] = Q_bound[electricity_prod_switch] * (
            y1 - y2
        ) / (x1 - x2) + (y1 - (y1 - y2) / (x2 - x1) * x1)
        cost = (-Q * a[0] - electricity_prod * (a[1] - electricity_price)) / MW_W

        ms = self.sim.grid.edges[0].mass_flow
        for consumer in self.sim.grid.consumers:
            consumer_in_temp = consumer.temp[0]
            consumer_out_temp = consumer.temp[1]

        for producer in self.sim.grid.producers:
            return_out_temp = producer.temp[1]
        return (
            cost,
            plug_states,
            [
                Q,
                electricity_prod,
                ms,
                consumer_in_temp,
                consumer_out_temp,
                return_out_temp,
            ],
        )

    def calculate_basic_strategy_cost(self):
        """
        Calculate costs based on the basic control strategy.
        """
        costs = []
        for i in range(self.number_of_episodes):
            heat_demand = self.heat_demand[i]
            electricity_price = self.electricity_price[i]
            cost = self.optimize(heat_demand, electricity_price)
            """
            save_to_pickle(
                data_path_store=self.store_p,
                variable=cost[0],
                variable_name="basic_strategy",
                pipe_len=self.pipe_len,
                now=self.now,
                ep=i + 1,
            )
            """
            costs.append(np.sum(cost[0]))
        """
        save_to_pickle(
            data_path_store=self.store_p,
            variable=costs,
            variable_name="basic_strategy_sum",
            pipe_len=self.pipe_len,
            now=self.now,
            ep="all",
        )
        """
